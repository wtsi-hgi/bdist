#!/bin/bash

# Submit a distributed job to your LSF compute cluster
# Author: Christopher Harrison <ch12@sanger.ac.uk>

# GPLv3, or later
# Copyright (c) 2016 Genome Research Ltd.

set -eu -o pipefail

PROGNAME=$(basename "$0")
BDIST_BIN=$(readlink -f "$0")
VERSION="0.0.1"

BDIST_ROOT="$HOME/.bdist"
BDIST_WORK="$BDIST_ROOT/work"
BDIST_LOGS="$BDIST_ROOT/logs"

usage() {
  cat <<-EOF
	Usage: $PROGNAME -c COMMAND [OPTIONS] (--fofn FILE | FILE ...)
	       $PROGNAME (-V | --version)
	       $PROGNAME (-h | --help)
	
	COMMAND will be run against all the specified FILEs (or a file of
	filenames, when used with --fofn), distributed across an LSF cluster.
	
	The following bsub(1) options may also be specified and follow the same
	usage therefrom:
	
	  -J JOB_NAME
	  -M MEM_LIMIT
	  -R RESOURCE_REQ
	  -n MIN_CPUS[,MAX_CPUS]
	  -q QUEUE_NAME
	
	Note that JOB_NAME, if specified, must be a simple identifier. If not
	specified, one will be automatically created.
	EOF
}

display_version() {
  cat <<-EOF
	bdist v$VERSION
	Copyright (c) 2016 Genome Research Ltd.
	
	This program comes with ABSOLUTELY NO WARRANTY. This is free software,
	which you are welcome to redistribute under the conditions of the GNU
	Public License v3, or later.
	EOF
}

stderr() {
  # echo to stderr in ANSI red
  >&2 echo -e "\033[0;31m$@\033[0m"
}

fail_because() {
  local reason=$1

  stderr $reason
  usage
  exit 1
}

fail_if_interactive() {
  # FIXME This should trigger whenever not run by bsub
  # e.g. check LSF environment variables?...
  [ -t 0 -o -t 1 ] && fail_because "Not for interactive use"
}

random_job_name() {
  dd if=/dev/urandom bs=12 count=1 2>/dev/null \
  | base64 \
  | tr "+/" "-_"
}

init_bdist_dir() {
  mkdir -p "$BDIST_WORK"
  mkdir -p "$BDIST_LOGS"
}

get_max_job_array_size() {
  # Note \y is GNU Awk specific
  local default=1000

  bparams -a \
  | awk -F " *= *" '/\yMAX_JOB_ARRAY_SIZE\y/ { print $2; found = 1 }
                    END { if (!found) exit 1 }' \
  || echo $default
}

main() {
  local cmd
  local job_name
  local -a bsub_options
  local fofn
  local -a files

  if [ "$#" -eq "0" ]; then
    usage
    exit 1
  fi

  # Parse command line arguments
  while (( "$#" )); do
    case "$1" in
      "_run")
        fail_if_interactive
        # TODO
        exit
        ;;

      "_cleanup")
        fail_if_interactive
        # TODO
        exit
        ;;

      "-h" | "--help")
        usage
        exit
        ;;

      "-V" | "--version")
        display_version
        exit
        ;;

      "-c")
        shift
        cmd="${1:-}"
        ;;

      "--fofn")
        shift
        fofn="${1:-}"

        # Sanity check fofn
        [ ! -f "$fofn" ] && fail_because "Invalid FOFN"

        while read file; do
          [ ! -f "$file" ] && fail_because "FOFN contains invalid input file: \"$file\""
        done < "$fofn"
        ;;

      "-J")
        # Job name
        shift
        job_name="${1:-}"

        # Sanity check job name
        [[ ! "$job_name" =~ ^[a-zA-Z0-9._-]+$ ]] && fail_because "Invalid job name"
        ;;

      -[MRnq])
        # bsub option passthrough
        bsub_options+=("$1")
        shift
        bsub_options+=("\"${1:-}\"")
        ;;

      *)
        # Anything else we presume to be an file
        [ ! -f "$1" ] && fail_because "\"$1\" is not a valid input file"
        files+=("$1")
        ;;
    esac

    shift
  done
  
  # We must have a genuine command
  [ -z "${cmd:-}" ] && fail_because "No command specified"
  ! command -v "${cmd%% *}" &>/dev/null && fail_because "Invalid command"

  # FOFN > files, we can't have both, but we must have something
  [ -n "${fofn:-}" -a "${#files[@]}" -ne "0" ] && fail_because "Please supply a FOFN or input files, not both"
  [ -z "${fofn:-}" -a "${#files[@]}" -eq "0" ] && fail_because "No FOFN or input files specified"

  # Create random job name, if none specified, and create working dir
  if [ -z "${job_name:-}" ]; then
    job_name="$(random_job_name)"
  fi

  init_bdist_dir
  local working_dir="$BDIST_WORK/$job_name"
  mkdir "$working_dir"

  # If we're given explicit input files, create a FOFN from them
  if [ -z "${fofn:-}" ]; then
    fofn="$working_dir/fofn"
    printf "%s\n" "${files[@]}" > "$fofn"
  fi

  # Make sure we're not submitting too many input files (or too few)
  local file_count=$(wc -l < "$fofn")
  if [ "$file_count" -gt "$(get_max_job_array_size)" -o "$file_count" -eq "0" ]; then
    # TODO Clean up

    if [ "$file_count" -eq "0" ]; then
      fail_because "No input files to process"
    else
      fail_because "Too many input files to process"
    fi
  fi

  # TODO
  # Submit the job array and the clean up operation
  echo -n "Creating job array \"$job_name\" with $file_count elements... " \
  && bsub -J "${job_name}[1-${file_count}]" \
          -o $LOG \
          ${bsub_options[@]} \
          $SOMETHING &>/dev/null \
  && bsub -J "cleanup_${job_name}" \
          -w "ended(${job_name})" \
          $SOMETHING &>/dev/null \
  && echo "Done!" \
  || { echo "Failed!"; exit 1; }
}

main "$@"
